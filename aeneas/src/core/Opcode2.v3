// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Represents the statically-known part of an operation, not including the types.
type Opcode2 {
	// Boolean operators
	case BoolEq;
	case BoolAnd;
	case BoolOr;
	case BoolNot;
	// Integer arithmetic and conversions
	case IntEq(t: IntType);
	case IntAdd(t: IntType);
	case IntSub(t: IntType);
	case IntMul(t: IntType);
	case IntDiv(t: IntType);
	case IntMod(t: IntType);
	case IntAnd(t: IntType);
	case IntOr(t: IntType);
	case IntXor(t: IntType);
	case IntShl(t: IntType);
	case IntSar(t: IntType);
	case IntShr(t: IntType);
	case IntLt(t: IntType);
	case IntLteq(t: IntType);
	case IntWide(op: Operator, paramTypes: Array<Type>, resultTypes: Array<Type>);
	// Floating point arithmetic
	case FloatAdd(t: FloatType);
	case FloatSub(t: FloatType);
	case FloatMul(t: FloatType);
	case FloatDiv(t: FloatType);
	case FloatBitEq(t: FloatType);
	case FloatEq(t: FloatType);
	case FloatNe(t: FloatType);
	case FloatLt(t: FloatType);
	case FloatLteq(t: FloatType);
	case FloatAbs(t: FloatType);
	case FloatCeil(t: FloatType);
	case FloatFloor(t: FloatType);
	case FloatSqrt(t: FloatType);
	// Integer casts and conversions
	case IntCastF(to: IntType, from: FloatType);
	case IntQueryF(to: IntType, from: FloatType);
	case IntViewI(to: IntType, from: IntType);
	case IntViewF(to: IntType, from: FloatType);
	case IntTruncF(to: IntType, from: FloatType);
	// Floating point casts and conversions
	case FloatCastI(to: FloatType, from: IntType);
	case FloatCastD(to: FloatType, from: FloatType);
	case FloatQueryI(to: FloatType, from: IntType);
	case FloatQueryD(to: FloatType, from: FloatType);
	case FloatPromoteI(to: FloatType, from: IntType);
	case FloatPromoteF(to: FloatType, from: FloatType);
	case FloatViewI(to: FloatType, from: IntType);
	case FloatRoundI(to: FloatType, from: FloatType);
	case FloatRound(to: FloatType, from: FloatType);
	case FloatRoundD(to: FloatType, from: FloatType);
	// Reference equality
	case RefEq(t: Type);
	// Tuple operations
	case TupleCreate(t: TupleType, length: int);
	case TupleGetElem(t: TupleType, index: int);
	// Array operations
	case ArrayAlloc(t: ArrayType);
	case ArrayInit(t: ArrayType, length: int);
	case ArrayTupleInit(t: ArrayType, elems: int, length: int);
	case ArrayGetElem(t: ArrayType, it: IntType);
	case ArraySetElem(t: ArrayType, it: IntType);
	case ArrayGetElemElem(t: ArrayType, it: IntType, index: int);
	case ArraySetElemElem(t: ArrayType, it: IntType, index: int);
	case ArrayGetLength(t: ArrayType);
	// Range operations
	case RangeFromTo(t: RangeType);
	case RangeFromPlus(t: RangeType);
	case RangeGetElem(t: RangeType, it: IntType);
	case RangeSetElem(t: RangeType, it: IntType);
	case RangeGetLength(t: RangeType);
	case RangeStartPlusIndex(t: RangeType, it: IntType);
	case RangeStartFromPointer(t: RangeType, pt: PointerType);
	// Normalized Range operations
	case NormRangeGetElem(t: RangeType, it: IntType);
	case NormRangeGetElemElem(t: RangeType, index: int, it: IntType);
	case NormRangeSetElem(t: RangeType, it: IntType);
	case NormRangeSetElemElem(t: RangeType, index: int, it: IntType);
	// Component operations
	case Init(method: IrMethod);
	case ComponentGetField(field: IrField);
	case ComponentSetField(field: IrField);
	// Class operations
	case ClassAlloc(spec: IrSpec);
	case ClassGetField(spec: IrSpec);
	case ClassInitField(spec: IrSpec);
	case ClassSetField(spec: IrSpec);
	case ClassGetMethod(spec: IrSpec);
	case ClassGetVirtual(spec: IrSpec);
	case ClassGetSelector(spec: IrSpec);
	// Variant operations
	case VariantEq(t: ClassType);
	case VariantGetTag(t: ClassType);
	case VariantGetField(spec: IrSpec);
	case VariantGetMethod(spec: IrSpec);
	case VariantGetVirtual(spec: IrSpec);
	case VariantGetSelector(spec: IrSpec);
	// Safety checks
	case NullCheck(t: Type);
	case BoundsCheck(t: Type);
	case ConditionalThrow(exception: string);
	// Overloaded, polymorphic casts
	case OverloadedEq(t: Type);
	case TypeCast(cast: TypeCast, to: Type, from: Type);
	case TypeQuery(query: TypeQuery, to: Type, from: Type);
	case TypeSubsume(to: Type, from: Type);
	// Closure and call operations
	case CallMethod(spec: IrSpec);
	case CallClassMethod(spec: IrSpec);
	case CallClassVirtual(spec: IrSpec);
	case CallClassSelector(spec: IrSpec);
	case CallVariantVirtual(spec: IrSpec);
	case CallVariantSelector(spec: IrSpec);
	case CallClosure(t: FuncType);
	case CallFunction(t: FuncType);
	case CreateClosure(obj: Type, method: IrSpec);
	case ForgeClosure(ptrType: PointerType, closureType: Type, paramType: Type, resultType: Type);
	case UnpackClosure(ptrType: PointerType, closureType: Type, paramType: Type, resultType: Type);
	// RefLayout operations
	case RefLayoutAt(t: RefType);
	case RefLayoutOf(t: RefType);
	case RefLayoutIn(t: RefType, offset: int, rt: RefType);
	case RefLayoutGetField(t: RefType, offset: int, ft: Type);
	case RefLayoutSetField(t: RefType, offset: int, ft: Type);
	case RefLayoutAtRepeatedField(t: RefType, offset: int, scale: int, max: int, rt: RefType);
	case RefLayoutGetRepeatedField(t: RefType, offset: int, scale: int, max: int, ft: Type);
	case RefLayoutSetRepeatedField(t: RefType, offset: int, scale: int, max: int, ft: Type);
	case ByteArrayGetField(st: Type, offset: int, ft: Type);
	case ByteArraySetField(st: Type, offset: int, ft: Type);
	case ForgeRange(ptrType: PointerType, t: RangeType);
	// System operations
	case SystemCall(syscall: SystemCall, paramType: Type, resultType: Type);
	// Container for VST operations
	case VstSugar(op: VstOperator, paramType: Type, resultType: Type);

// ------- Machine-level operations ---------------------------------------------
	// Pointer operations
	case PtrAdd(t: PointerType, it: IntType);
	case PtrSub(t: PointerType, it: IntType);
	case PtrLt(t: PointerType);
	case PtrLteq(t: PointerType);
	case PtrAtContents(t: PointerType, at: Type);
	case PtrAtLength(t: PointerType, arrayType: ArrayType);
	case PtrAtObject(t: PointerType, objType: Type);
	case PtrAtRangeElem(t: PointerType, rangeType: RangeType, it: IntType);
	case PtrAtArrayElem(t: PointerType, arrayType: ArrayType, it: IntType);
	case PtrAtEnd(t: PointerType, objType: Type);
	case PtrAtRef(t: PointerType, refType: RefType);
	case PtrAtComponentField(t: PointerType, field: IrSpec);
	case PtrAtObjectField(t: PointerType, field: IrSpec);
	case PtrAtRefLayoutField(refType: RefType, t: PointerType, offset: int);
	case PtrCmpSwp(t: PointerType, valType: Type);
	case PtrLoad(t: PointerType, valType: Type);
	case PtrStore(t: PointerType, valType: Type);
	case PtrAddRangeStart(t: PointerType);
	// Get caller instruction pointer or stack pointer
	case CallerIp(t: PointerType);
	case CallerSp(t: PointerType);
	// Allocate raw memory
	case Alloc(t: Type);
	// Call
	case CallAddress(p: PointerType, rep: Mach_FuncRep);
	case CallKernel(kernel: Kernel, paramType: Type, resultType: Type);
}

component Opcodes2 {
	def table = Array<Fact.set>.new(Opcode2.CallKernel.tag + 1);
	new() {
		// shorthand for SSA optimization facts
		var F = Fact.O_FOLDABLE;
		var M = Fact.O_MONOMORPHIC;
		var P = Fact.O_PURE | Fact.O_FOLDABLE; // pure => foldable
		var C = Fact.O_COMMUTATIVE;
		var A = Fact.O_ASSOCIATIVE;
		var NZ   = Fact.V_NON_ZERO;
		var NNEG = Fact.V_NON_NEGATIVE;
		var NNC = Fact.O_NO_NULL_CHECK;
                var NONE = Facts.NONE;

		def t = table; // for code shortitude
		
		// register all operators and their optimization facts
		t[Opcode2.BoolEq.tag] =			P  |M|C;
		t[Opcode2.BoolAnd.tag] = 		P|A|M|C;
		t[Opcode2.BoolOr.tag] = 		P|A|M|C;
		t[Opcode2.BoolNot.tag] = 		P|M;

		t[Opcode2.IntEq.tag] =			P  |M|C;
		t[Opcode2.IntAdd.tag] = 		P|A|M|C;
		t[Opcode2.IntSub.tag] = 		P|M;
		t[Opcode2.IntMul.tag] = 		P|A|M|C;
		t[Opcode2.IntDiv.tag] = 		F|M;
		t[Opcode2.IntMod.tag] = 		F|M;
		t[Opcode2.IntAnd.tag] = 		P|A|M|C;
		t[Opcode2.IntOr.tag] = 			P|A|M|C;
		t[Opcode2.IntXor.tag] = 		P|A|M|C;
		t[Opcode2.IntShl.tag] = 		P|M;
		t[Opcode2.IntSar.tag] = 		P|M;
		t[Opcode2.IntShr.tag] = 		P|M;
		t[Opcode2.IntLt.tag] = 			P|M;
		t[Opcode2.IntLteq.tag] = 		P|M;
		t[Opcode2.IntWide.tag] = 		P|M;

		t[Opcode2.FloatAdd.tag] =		P|A|M|C;
		t[Opcode2.FloatSub.tag] =		P|M;
		t[Opcode2.FloatMul.tag] =		P|A|M|C;
		t[Opcode2.FloatDiv.tag] =		P|M;
		t[Opcode2.FloatBitEq.tag] =		P  |M|C;
		t[Opcode2.FloatEq.tag] =		P  |M|C;
		t[Opcode2.FloatNe.tag] =		P  |M|C;
		t[Opcode2.FloatLt.tag] =		P|M;
		t[Opcode2.FloatLteq.tag] =		P|M;
		t[Opcode2.FloatAbs.tag] =		P|M;
		t[Opcode2.FloatCeil.tag] =		P|M;
		t[Opcode2.FloatFloor.tag] =		P|M;
		t[Opcode2.FloatSqrt.tag] =		P|M;

		t[Opcode2.IntCastF.tag] =		F|M;
		t[Opcode2.IntQueryF.tag] =		P|M;
		t[Opcode2.IntViewI.tag] = 		P|M;
		t[Opcode2.IntViewI.tag] =		P|M;
		t[Opcode2.IntViewF.tag] =		P|M;
		t[Opcode2.IntTruncF.tag] =		P|M;

		t[Opcode2.FloatCastI.tag] =		F|M;
		t[Opcode2.FloatCastD.tag] =		F|M;
		t[Opcode2.FloatQueryI.tag] =		P|M;
		t[Opcode2.FloatQueryD.tag] =		P|M;
		t[Opcode2.FloatPromoteI.tag] =		P|M;
		t[Opcode2.FloatPromoteF.tag] =		P|M;
		t[Opcode2.FloatViewI.tag] =		P|M;
		t[Opcode2.FloatRoundI.tag] =		P|M;
		t[Opcode2.FloatRound.tag] =		P|M;
		t[Opcode2.FloatRoundD.tag] =		P|M;

		t[Opcode2.RefEq.tag] =			P  |C;

		t[Opcode2.TupleCreate.tag] = 		P;
		t[Opcode2.TupleGetElem.tag] = 		P;

		t[Opcode2.ArrayAlloc.tag] = 		NZ;
		t[Opcode2.ArrayInit.tag] = 		NZ;
		t[Opcode2.ArrayGetElem.tag] = 		NONE;
		t[Opcode2.ArraySetElem.tag] = 		NONE;
		t[Opcode2.ArrayGetLength.tag] = 	F|NNEG;

		t[Opcode2.RangeFromTo.tag] = 		F;
		t[Opcode2.RangeFromPlus.tag] = 		F;
		t[Opcode2.RangeGetLength.tag] = 	P;

		t[Opcode2.RangeStartPlusIndex.tag] =	P;
		t[Opcode2.RangeStartFromPointer.tag] =	P;
		t[Opcode2.NormRangeGetElem.tag] = 	F;
		t[Opcode2.NormRangeGetElemElem.tag] = 	F;
		t[Opcode2.NormRangeSetElem.tag] = 	NONE;
		t[Opcode2.NormRangeSetElemElem.tag] = 	NONE;
		t[Opcode2.PtrAddRangeStart.tag] =	P;
		t[Opcode2.ForgeRange.tag] =		P;

		t[Opcode2.Init.tag] = 			M;
		t[Opcode2.ComponentGetField.tag] = 	NNC|M;
		t[Opcode2.ComponentSetField.tag] = 	NNC|M;

		t[Opcode2.ClassAlloc.tag] = 		NZ;
		t[Opcode2.ClassGetField.tag] = 		NONE;
		t[Opcode2.ClassSetField.tag] = 		NONE;
		t[Opcode2.ClassInitField.tag] = 	Fact.O_NO_NULL_CHECK;
		t[Opcode2.ClassGetMethod.tag] = 	NZ|F;
		t[Opcode2.ClassGetVirtual.tag] = 	NZ|F;
		t[Opcode2.ClassGetSelector.tag] = 	NZ|F;

		t[Opcode2.VariantEq.tag] =		P  |C;
		t[Opcode2.VariantGetTag.tag] =		P|NNEG;
		t[Opcode2.VariantGetField.tag] = 	P;
		t[Opcode2.VariantGetMethod.tag] = 	NZ|P;
		t[Opcode2.VariantGetVirtual.tag] = 	NZ|P;
		t[Opcode2.VariantGetSelector.tag] = 	NZ|P;

		t[Opcode2.NullCheck.tag] = 		F|NZ;
		t[Opcode2.BoundsCheck.tag] = 		F;
		t[Opcode2.ConditionalThrow.tag] = 	F|M;

		t[Opcode2.OverloadedEq.tag] =		P  |C;
		t[Opcode2.TypeCast.tag] = 		F;
		t[Opcode2.TypeQuery.tag] = 		P;
		t[Opcode2.TypeSubsume.tag] = 		P;

		t[Opcode2.CallMethod.tag] = 		NONE;
		t[Opcode2.CallClassVirtual.tag] = 	NONE;
		t[Opcode2.CallClassSelector.tag] = 	NONE;
		t[Opcode2.CallClosure.tag] = 		NONE;
		t[Opcode2.CallFunction.tag] = 		NONE;
		t[Opcode2.CreateClosure.tag] = 		NZ|P|NNC;
		t[Opcode2.ForgeClosure.tag] = 		P|NNC;
		t[Opcode2.UnpackClosure.tag] = 		P|NNC;

		t[Opcode2.SystemCall.tag] = 		NONE;

		t[Opcode2.PtrAdd.tag] =			P|M; // XXX: could be foldable with offset
		t[Opcode2.PtrSub.tag] =			P|M;
		t[Opcode2.PtrLt.tag] =			P|M;
		t[Opcode2.PtrLteq.tag] =		P|M;
		t[Opcode2.PtrAtContents.tag] =		P;
		t[Opcode2.PtrAtLength.tag] =		P;
		t[Opcode2.PtrAtObject.tag] =		P;
		t[Opcode2.PtrAtRangeElem.tag] =		F|M;
		t[Opcode2.PtrAtArrayElem.tag] =		F|M;
		t[Opcode2.PtrAtComponentField.tag] =	P|M;
		t[Opcode2.PtrAtObjectField.tag] =	F;
		t[Opcode2.PtrLoad.tag] =		NONE;
		t[Opcode2.PtrStore.tag] =		NONE;

		t[Opcode2.CallerIp.tag] =		P|M;
		t[Opcode2.CallerSp.tag] =		P|M;

		t[Opcode2.Alloc.tag] =			NONE;

		t[Opcode2.RefLayoutAt.tag] = 		NZ|F|M;
		t[Opcode2.RefLayoutIn.tag] = 		P|F|M;
		t[Opcode2.RefLayoutGetField.tag] =	NONE;
		t[Opcode2.RefLayoutAtRepeatedField.tag] = P|M;
	}
	def facts(opcode: Opcode2) -> Fact.set { return table[opcode.tag]; }
	def checkOpenness(opcode: Opcode2) -> Open {
		if (table[opcode.tag].O_MONOMORPHIC) return Open.CLOSED;
		var open = Open.OPEN;
		match (opcode) {
			RefEq(t) =>				open = isOpenType(t);
			TupleCreate(t, length) => 		open = isOpenType(t);
			TupleGetElem(t, index) => 		open = isOpenType(t);
			ArrayAlloc(t) =>			open = isOpenType(t);
			ArrayInit(t, length) =>			open = isOpenType(t);
			ArrayTupleInit(t, elems, length) => 	open = isOpenType(t);
			ArrayGetElem(t, it) =>			open = isOpenType(t);
			ArraySetElem(t, it) =>			open = isOpenType(t);
			ArrayGetElemElem(t, it, index) => 	open = isOpenType(t);
			ArraySetElemElem(t, it, index) => 	open = isOpenType(t);
			ArrayGetLength(t) =>			open = isOpenType(t);
			RangeFromTo(t) =>			open = isOpenType(t);
			RangeFromPlus(t) =>			open = isOpenType(t);
			RangeGetElem(t, it) =>			open = isOpenType(t);
			RangeSetElem(t, it) =>			open = isOpenType(t);
			RangeGetLength(t) =>			open = isOpenType(t);
			RangeStartPlusIndex(t, it) =>		open = isOpenType(t);
			RangeStartFromPointer(t, pt) =>		open = isOpenType(t);
			NormRangeGetElem(t, it) =>		open = isOpenType(t);
			NormRangeGetElemElem(t, index, it) =>	open = isOpenType(t);
			NormRangeSetElem(t, it) =>		open = isOpenType(t);
			NormRangeSetElemElem(t, index, it) =>	open = isOpenType(t);
			ClassAlloc(spec) => 			open = isOpenSpec(spec);
			ClassGetField(spec) => 			open = isOpenSpec(spec);
			ClassInitField(spec) =>			open = isOpenSpec(spec);
			ClassSetField(spec) => 			open = isOpenSpec(spec);
			ClassGetMethod(spec) =>			open = isOpenSpec(spec);
			ClassGetVirtual(spec) => 		open = isOpenSpec(spec);
			ClassGetSelector(spec) => 		open = isOpenSpec(spec);
			VariantEq(t) =>				open = isOpenType(t);
			VariantGetTag(t) =>			open = isOpenType(t);
			VariantGetField(spec) => 		open = isOpenSpec(spec);
			VariantGetMethod(spec) => 		open = isOpenSpec(spec);
			VariantGetVirtual(spec) => 		open = isOpenSpec(spec);
			VariantGetSelector(spec) => 		open = isOpenSpec(spec);
			NullCheck(t) =>				open = isOpenType(t);
			BoundsCheck(t) =>			open = isOpenType(t);
			OverloadedEq(t) =>			open = isOpenType(t);
			TypeCast(cast, to, from) =>		open = isOpenType2(to, from);
			TypeQuery(query, to, from) =>		open = isOpenType2(to, from);
			TypeSubsume(to, from) =>		open = isOpenType2(to, from);
			CallMethod(spec) => 			open = isOpenSpec(spec);
			CallClassMethod(spec) => 		open = isOpenSpec(spec);
			CallClassVirtual(spec) => 		open = isOpenSpec(spec);
			CallClassSelector(spec) => 		open = isOpenSpec(spec);
			CallVariantVirtual(spec) => 		open = isOpenSpec(spec);
			CallVariantSelector(spec) => 		open = isOpenSpec(spec);
			CallClosure(t) => 			open = isOpenType(t);
			CallFunction(t) => 			open = isOpenType(t);
			CreateClosure(obj, method) => 		open = isOpenTypeOrSpec(obj, method);
			ForgeClosure(ptrType, closureType, paramType, resultType) => 	open = isOpenTypes([closureType, paramType, resultType]);
			UnpackClosure(ptrType, closureType, paramType, resultType) => 	open = isOpenTypes([closureType, paramType, resultType]);
			RefLayoutGetField(t, offset, ft) =>				open = isOpenType(ft);
			RefLayoutSetField(t, offset, ft) =>				open = isOpenType(ft);
			RefLayoutGetRepeatedField(t, offset, scale, max, ft) =>		open = isOpenType(ft);
			RefLayoutSetRepeatedField(t, offset, scale, max, ft) =>		open = isOpenType(ft);
			ByteArrayGetField(st, offset, ft) =>				open = isOpenType(ft);
			ByteArraySetField(st, offset, ft) =>				open = isOpenType(ft);
			ForgeRange(ptrType, t) => 					open = isOpenType(t);
			SystemCall(syscall, paramType, resultType) =>			open = isOpenType2(paramType, resultType);
			VstSugar(op, paramType, resultType) =>				open = isOpenType2(paramType, resultType);
			PtrAtContents(t, at) =>						open = isOpenType(t);
			PtrAtLength(t, arrayType) =>					open = isOpenType(arrayType);
			PtrAtObject(t, objType) =>					open = isOpenType(objType);
			PtrAtEnd(t, objType) =>						open = isOpenType(objType);
			PtrAtObjectField(t, field) =>					open = isOpenType(t);
			PtrAtRefLayoutField(refType, t, offset) =>			open = isOpenType(t);
			PtrCmpSwp(t, valType) =>					open = isOpenType(valType);
			PtrLoad(t, valType) =>						open = isOpenType(valType);
			PtrStore(t, valType) =>						open = isOpenType(valType);
			Alloc(t) =>							open = isOpenType(t);
			CallAddress(p, rep) => 						; // TODO
			CallKernel(kernel, paramType, resultType) => 	open = isOpenType2(paramType, resultType);
			_ => ;
		}
		return open;
	}
	def isOpenType(t: Type) -> Open;
	def isOpenTypes(t: Range<Type>) -> Open;
	def isOpenSpec(spec: IrSpec) -> Open;
	def isOpenTypeOrSpec(t: Type, spec: IrSpec) -> Open;
	def isOpenType2(t1: Type, t2: Type) -> Open;
}
